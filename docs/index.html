<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>AnthropicClient | AnthropicClient </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="AnthropicClient | AnthropicClient ">
      
      
      <link rel="icon" href="favicon.ico">
      <link rel="stylesheet" href="public/docfx.min.css">
      <link rel="stylesheet" href="public/main.css">
      <meta name="docfx:navrel" content="toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="">
      
      
      <meta name="docfx:docurl" content="https://github.com/StevanFreeborn/anthropic-client/blob/main/docfx/index.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="index.html">
            <img id="logo" class="svg" src="logo.svg" alt="AnthropicClient">
            AnthropicClient
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="anthropicclient">AnthropicClient</h1>

<p><a href="https://github.com/StevanFreeborn/anthropic-client/actions/workflows/pull_request.yml"><img src="https://github.com/StevanFreeborn/anthropic-client/actions/workflows/pull_request.yml/badge.svg" alt="Pull Request"></a>
<a href="https://codecov.io/gh/StevanFreeborn/anthropic-client"><img src="https://codecov.io/gh/StevanFreeborn/anthropic-client/graph/badge.svg?token=hZ3MjhxDv9" alt="codecov"></a>
<a href="https://github.com/StevanFreeborn/anthropic-client/actions/workflows/publish.yml"><img src="https://github.com/StevanFreeborn/anthropic-client/actions/workflows/publish.yml/badge.svg" alt="Publish"></a>
<a href="https://github.com/semantic-release/semantic-release"><img src="https://img.shields.io/badge/semantic--release-angular-e10079?logo=semantic-release" alt="semantic-release: angular"></a>
<img src="https://img.shields.io/nuget/v/AnthropicClient" alt="NuGet Version">
<img src="https://img.shields.io/nuget/dt/AnthropicClient" alt="NuGet Downloads"></p>
<p>This library for the Anthropic API is meant to simplify development in C# for Anthropic users.</p>
<div class="NOTE">
<h5>Note</h5>
<p>This is an unofficial SDK for the Anthropic API. It was not built in consultation with Anthropic or any member of their organization.</p>
</div>
<p>This SDK was developed independently using existing libraries and the Anthropic API documentation as the starting point with the intention of making development of integrations done in C# with Anthropic quicker and more convenient.</p>
<div class="NOTE">
<h5>Note</h5>
<p>This client library is heavily inspired by the <a href="https://github.com/tghamm/Anthropic.SDK">Anthropic.SDK</a> library. I chose to create a new library because I wanted to handle streaming and tool calling differently as well as have control over the client library as I plan to use it to build a connector for <a href="https://github.com/microsoft/semantic-kernel">SemanticKernel</a>. However if you are looking for a client library the Anthropic.SDK is a great place to start.</p>
</div>
<h2 id="-issues">üìù Issues</h2>
<p>If you encounter any issues while using this library please open an issue <a href="https://github.com/StevanFreeborn/anthropic-client/issues">here</a>.</p>
<h2 id="-license">üìú License</h2>
<p>This library is licensed under the <a href="https://choosealicense.com/licenses/mit/">MIT License</a> and is free to use and modify.</p>
<h2 id="-contributing">üìù Contributing</h2>
<p>If you would like to contribute to this library please open a pull request <a href="https://github.com/StevanFreeborn/anthropic-client/pulls">here</a>.</p>
<h2 id="-dependencies">üõ†Ô∏è Dependencies</h2>
<h3 id="microsoftbclasyncinterfaces"><a href="https://www.nuget.org/packages/Microsoft.Bcl.AsyncInterfaces/">Microsoft.Bcl.AsyncInterfaces</a></h3>
<p><img src="https://img.shields.io/nuget/v/Microsoft.Bcl.AsyncInterfaces" alt="Microsoft.Bcl.AsyncInterfaces NuGet Version"></p>
<p>Used to support async interfaces when streaming messages</p>
<h3 id="systemtextjson"><a href="https://www.nuget.org/packages/System.Text.Json/">System.Text.Json</a></h3>
<p><img src="https://img.shields.io/nuget/v/System.Text.Json" alt="NuGet Version"></p>
<p>Used for JSON serialization and deserialization</p>
<h2 id="-installation">üíæ Installation</h2>
<p>Install the package from <a href="https://www.nuget.org">NuGet</a> using the following command:</p>
<pre><code class="lang-bash">dotnet add package AnthropicClient
</code></pre>
<h2 id="-api-key">üîë API Key</h2>
<p>In order to use the Anthropic API you will need an API key. You can get one by signing up at <a href="https://www.anthropic.com/api">Anthropic</a>. Please keep your API key secure and do not share it with others. Be mindful of where you store your API key and do not commit it to a public repository.</p>
<h2 id="-start-coding">üë®üèª‚Äçüíª Start Coding</h2>
<h3 id="anthropicapiclient"><code>AnthropicApiClient</code></h3>
<p>The most common way to use the SDK is to create an <code>AnthropicApiClient</code> instance and call its methods. Its constructor requires two parameters:</p>
<ul>
<li><code>apiKey</code> - your Anthropic API key</li>
<li><code>httpClient</code> - an <code>HttpClient</code> instance. You can configure and customize the <code>HttpClient</code> instance as needed. This library however will perform the necessary configuration to work with the Anthropic API. Such as setting the base address and adding the proper headers.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>This library does not manage the lifecycle of the <code>HttpClient</code> instance. You should create and manage the lifecycle of the <code>HttpClient</code> instance in your application.</p>
</div>
<p>It is best practice to read the API key from a secure location such as a configuration file or environment variable. For example using the <code>appsettings.json</code> file:</p>
<pre><code class="lang-json">{
  &quot;AnthropicApiKey&quot;: &quot;YOUR_API&quot;
}
</code></pre>
<p>Example constructing an <code>AnthropicApiClient</code> instance:</p>
<pre><code class="lang-csharp">using AnthropicClient;
using Microsoft.Extensions.Configuration;

var configuration = new ConfigurationBuilder()
  .AddJsonFile(&quot;appsettings.json&quot;)
  .Build();

var apiKey = configuration[&quot;AnthropicApiKey&quot;];

var client = new AnthropicApiClient(apiKey, new HttpClient());
</code></pre>
<h3 id="ianthropicapiclient"><code>IAnthropicApiClient</code></h3>
<p>The library does expose an interface <code>IAnthropicApiClient</code> that can be used for dependency injection and testing. The interface is implemented by the <code>AnthropicApiClient</code> class.</p>
<h3 id="full-api-documentation">Full API Documentation</h3>
<p>This library was developed to make using the Anthropic API easier within a .NET application. If you are looking for the full API documentation you can find it at <a href="https://docs.anthropic.com/">Anthropic API Documentation</a>.</p>
<h2 id="usage">Usage</h2>
<p>The primary use case for working with the Anthropic API is to create a message in response to a request that includes one or more other messages. The created message can then be received either as a complete response or a stream of events. This can be used to create a conversation between the caller and Anthropic's AI models and/or to use Anthropic's AI models to perform a task.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The following examples assume that you have already created an instance of the <code>AnthropicApiClient</code> class named <code>client</code>. You can also find these snippets in the examples directory.</p>
</div>
<h3 id="count-message-tokens">Count Message Tokens</h3>
<p>The <code>AnthropicApiClient</code> exposes a method named <code>CountMessageTokensAsync</code> that can be used to count the number of tokens in a message. The method requires a <code>CountMessageTokensRequest</code> instance as a parameter.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var response = await client.CountMessageTokensAsync(new CountMessageTokensRequest(
  AnthropicModels.Claude3Haiku,
  [
    new(
      MessageRole.User, 
      [new TextContent(&quot;Please write a haiku about the ocean.&quot;)]
    )
  ]
));

if (response.IsFailure)
{
  Console.WriteLine(&quot;Failed to count message tokens&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

Console.WriteLine(&quot;Token Count: {0}&quot;, response.Value.InputTokens);
</code></pre>
<h3 id="list-models">List Models</h3>
<p>The <code>AnthropicApiClient</code> exposes a method named <code>ListModelsAsync</code> that can be used to list the available models. The method takes an optional <code>PagingRequest</code> instance as a parameter.</p>
<pre><code class="lang-csharp">using AnthropicClient;

var response = await client.ListModelsAsync();

if (response.IsFailure)
{
  Console.WriteLine(&quot;Failed to list models&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

foreach (var model in response.Value.Data)
{
  Console.WriteLine(&quot;Model Id: {0}&quot;, model.Id);
  Console.WriteLine(&quot;Model Name: {0}&quot;, model.DisplayName);
}
</code></pre>
<p>Using the <code>PagingRequest</code> instance allows you to specify the number of models to return and the page of models to return.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var response = await client.ListModelsAsync(new PagingRequest(afterId: &quot;claude-3-5-sonnet-20241022&quot;, limit: 2));

if (response.IsFailure)
{
  Console.WriteLine(&quot;Failed to list models&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

foreach (var model in response.Value.Data)
{
  Console.WriteLine(&quot;Model Id: {0}&quot;, model.Id);
  Console.WriteLine(&quot;Model Name: {0}&quot;, model.DisplayName);
}
</code></pre>
<h3 id="get-model">Get Model</h3>
<p>The <code>AnthropicApiClient</code> exposes a method named <code>GetModelAsync</code> that can be used to get a model by its id.</p>
<pre><code class="lang-csharp">using AnthropicClient;

var response = await client.GetModelAsync(&quot;claude-3-5-sonnet-20241022&quot;);

if (response.IsFailure)
{
  Console.WriteLine(&quot;Failed to get model&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

Console.WriteLine(&quot;Model Id: {0}&quot;, response.Value.Id);
</code></pre>
<h3 id="create-a-message">Create a message</h3>
<p>The <code>AnthropicApiClient</code> exposes a method named <code>CreateMessageAsync</code> that can be used to create a message. The method requires a <code>MessageRequest</code> or a <code>StreamMessageRequest</code> instance as a parameter. The <code>MessageRequest</code> class is used to create a message whose response is not streamed and the <code>StreamMessageRequest</code> class is used to create a message whose response is streamed. The <code>MessageRequest</code> instance's properties can be set to configure how the message is created.</p>
<h4 id="non-streaming">Non-Streaming</h4>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var response = await client.CreateMessageAsync(new MessageRequest(
  AnthropicModels.Claude3Haiku,
  [
    new(
      MessageRole.User, 
      [new TextContent(&quot;Please write a haiku about the ocean.&quot;)]
    )
  ]
));

if (response.IsSuccess is false)
{
  Console.WriteLine(&quot;Failed to create message&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

foreach (var content in response.Value.Content)
{
  switch (content)
  {
    case TextContent textContent:
      Console.WriteLine(textContent.Text);
      break;
  }
}
</code></pre>
<h4 id="streaming">Streaming</h4>
<p>Anthropic uses Server-Sent Events (SSE) to stream messages. The possible events and the format of those events are documented in the <a href="https://docs.anthropic.com/en/api/messages-streaming">Anthropic API Documentation</a>. This library provides a way to consume them after they have been deserialized into strongly-typed C# objects that are returned in an <code>IAsyncEnumerable</code> collection.</p>
<p>This allows you to consume the events as they are received and process them in the way that best fits your use case. The following example demonstrates how to consume the streamed events and build up the complete text response from the model.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var events = client.CreateMessageAsync(new StreamMessageRequest(
  AnthropicModels.Claude3Haiku,
  [
    new(
      MessageRole.User, 
      [new TextContent(&quot;Please write a haiku about the ocean.&quot;)]
    )
  ]
));

var msgBuilder = new StringBuilder();

await foreach (var e in events)
{
  switch (e.Data)
  {
    case var data when data is ContentDeltaEventData contentData:
      switch (contentData.Delta)
      {
        case var delta when delta is TextDelta textDelta:
          msgBuilder.Append(textDelta.Text);
          break;
      }
      break;
  }
}

Console.WriteLine(msgBuilder.ToString());
</code></pre>
<h5 id="message-complete-event">Message Complete Event</h5>
<p>This library also provides a custom <code>message_complete</code> event that is yielded when all the message's events have been received. This event is not part of Anthropic's SSE events but is provided to allow for easier consumption of the entire message response if desired and make it easier to implement built-in tool calling.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var events = client.CreateMessageAsync(new StreamMessageRequest(
  AnthropicModels.Claude3Haiku,
  [
    new(
      MessageRole.User, 
      [new TextContent(&quot;Please write a haiku about the ocean.&quot;)]
    )
  ]
));

MessageResponse? response = null;

await foreach (var e in events)
{
  switch (e.Data)
  {
    case var data when data is MessageCompleteEventData msgData:
      response = msgData.Message;
      break;
  }
}

var textContent = response?.Content
  .OfType&lt;TextContent&gt;()
  .Aggregate(new StringBuilder(), (sb, c) =&gt; sb.Append(c.Text))
  .ToString();

Console.WriteLine(textContent);
</code></pre>
<h3 id="tool-use">Tool Use</h3>
<p>Anthropic's models support the use of tools to perform tasks. This allows the models to interact with external client-side tools that can perform actions the models cannot do natively. This gives you the ability to further extend the model's abilities with your own custom tools. This feature is covered in depth in <a href="https://docs.anthropic.com/en/docs/build-with-claude/tool-use">Anthropic's API Documentation</a>. This library aims to make using tools convenient by allowing you to create, provide, and call tools from within your application by leveraging the reflection capabilities of C#.</p>
<div class="NOTE">
<h5>Note</h5>
<p>All tools are user provided. The models do no not have access to any built-in server-side tools.</p>
</div>
<h4 id="create-a-tool">Create a tool</h4>
<p>You can create a tool in 4 different ways and then provide that tool when creating a message.</p>
<ol>
<li>Create a tool from a class</li>
<li>Create a tool from a static method</li>
<li>Create a tool from an instance method</li>
<li>Create a tool from a delegate</li>
</ol>
<h5 id="create-a-tool-from-a-class">Create a tool from a class</h5>
<p>When creating a tool from a class the class must implement the <code>ITool</code> interface.</p>
<pre><code class="lang-csharp">using AnthropicClient.Models;

class GetWeatherTool : ITool
{
  public string Name =&gt; &quot;Get Weather&quot;;

  public string Description =&gt; &quot;Get the weather for a location in the specified units&quot;;

  public MethodInfo Function =&gt; typeof(GetWeatherTool).GetMethod(nameof(GetWeather))!;

  public static string GetWeather(string location, string units)
  {
    return $&quot;The weather in {location} is 72 degrees {units}&quot;;
  }
}

var getWeatherTool = Tool.CreateFromClass&lt;GetWeatherTool&gt;();
</code></pre>
<h5 id="create-a-tool-from-a-static-method">Create a tool from a static method</h5>
<p>When creating a tool from a static method the method must be public and static.</p>
<pre><code class="lang-csharp">using AnthropicClient.Models;

class GetWeatherTool
{
  public static string GetWeather(string location)
  {
    return $&quot;The weather in {location} is 72 degrees Fahrenheit&quot;;
  }
}

var getWeatherTool = Tool.CreateFromStaticMethod(
  &quot;Get Weather&quot;, 
  &quot;Get the weather for a location in the specified units&quot;, 
  typeof(GetWeatherTool), 
  nameof(GetWeatherTool.GetWeather)
);
</code></pre>
<h5 id="create-a-tool-from-an-instance-method">Create a tool from an instance method</h5>
<p>When creating a tool from an instance method the method must be public and non-static.</p>
<pre><code class="lang-csharp">using AnthropicClient.Models;

class GetWeatherTool
{
  public string GetWeather(string location)
  {
    return $&quot;The weather in {location} is 72 degrees Fahrenheit&quot;;
  }
}

var toolInstance = new GetWeatherTool();

var getWeatherTool = Tool.CreateFromInstanceMethod(
  &quot;Get Weather&quot;, 
  &quot;Get the weather for a location in the specified units&quot;, 
  toolInstance,
  nameof(toolInstance.GetWeather)
);
</code></pre>
<h5 id="create-a-tool-from-a-delegate">Create a tool from a delegate</h5>
<p>When creating a tool from a delegate the delegate must be a <code>Func&lt;TResult&gt;</code>, <code>Func&lt;T, TResult&gt;</code>, or <code>Func&lt;T1, T2, TResult&gt;</code>. If you need to create a tool from a delegate that takes more than 2 parameters you should create a complex type and pass that as the parameter.</p>
<pre><code class="lang-csharp">using AnthropicClient.Models;

var tool = (string location, string units) =&gt; $&quot;The weather in {location} is 72 degrees {units}&quot;;

var getWeatherTool = Tool.CreateFromFunction(
  &quot;Get Weather&quot;, 
  &quot;Get the weather for a location in the specified units&quot;, 
  tool
);
</code></pre>
<h5 id="function-parameter-attribute">Function Parameter Attribute</h5>
<p>When you create a tool from one of the methods above and send it to Anthropic in your request a JSON representation of the tool is provided in the message. This JSON representation includes the name, description, and input schema of the tool. This information is used by Anthropic's models to discern if and when it should use a tool.</p>
<p>This library provides a <code>FunctionParameterAttribute</code> that can be used to provide additional information about the parameters of the tool. This information is used to provide a more detailed input schema for the tool.</p>
<pre><code class="lang-csharp">using AnthropicClient.Models;

var tool = (
  [FunctionParameter(description: &quot;The location of the weather being got&quot;, name: &quot;Location&quot;, required: true)] 
  string location, 
  string units
) =&gt; $&quot;The weather in {location} is 72 degrees {units}&quot;;

var getWeatherTool = Tool.CreateFromFunction(
  &quot;Get Weather&quot;, 
  &quot;Get the weather for a location in the specified units&quot;, 
  tool
);
</code></pre>
<h5 id="function-property-attribute">Function Property Attribute</h5>
<p>This library also provides a <code>FunctionPropertyAttribute</code> that can be used to provide additional information about the members of complex types used as parameters in the tool. This information is used to provide a more detailed input schema for the tool.</p>
<pre><code class="lang-csharp">using AnthropicClient.Models;

class GetWeatherInput
{
  [FunctionProperty(
    description: &quot;The location of the weather being got&quot;,
    required: true
  )]
  public string Location { get; } = string.Empty;

  [FunctionProperty(
    description: &quot;The units to get the weather in&quot;,
    required: false,
    defaultValue: &quot;Fahrenheit&quot;,
    possibleValues: [&quot;Fahrenheit&quot;, &quot;Celsius&quot;]
  )]
  public string Units { get; } = &quot;Fahrenheit&quot;;
}

  var tool = (GetWeatherInput input) =&gt; $&quot;The weather in {input.Location} is 72 degrees {input.Units}&quot;;

  var getWeatherTool = Tool.CreateFromFunction(
    &quot;Get Weather&quot;, 
    &quot;Get the weather for a location in the specified units&quot;, 
    tool
  );
</code></pre>
<h4 id="call-a-tool">Call a tool</h4>
<p>It is important to remember that while Anthropic's models do support tool use they don't actually have access to any built-in server-side tools. All tools are user provided. This means that while Anthropic's models can respond to a request to create a message with a request to use a tool that is all it is - a request. It is still up to the client to handle the tool request by calling the tool with the input provided by the model and then providing the result of that call back to the model.</p>
<p>This library aims to make this process convenient by allowing you to simply provide the tools you want Anthropic's models to consider for use when creating a message, receive the response, check if the response contains a tool call, and if it does invoke the tool to get the result.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Anthropic's API expects requests to contain messages that alternate between the user and the assistant. In addition if you receive a tool use from the model the API expects you to respond with a message that contains the result of the tool call. The tool use content will always be from the assistant while the tool result will always be from the user.</p>
</div>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

class GetWeatherTool : ITool
{
  public string Name =&gt; &quot;Get Weather&quot;;

  public string Description =&gt; &quot;Get the weather for a location in the specified units&quot;;

  public MethodInfo Function =&gt; typeof(GetWeatherTool).GetMethod(nameof(GetWeather))!;

  public static string GetWeather(string location, string units)
  {
    return $&quot;The weather in {location} is 72 degrees {units}&quot;;
  }
}

List&lt;Message&gt; messages = [
  new(
    MessageRole.User, 
    [new TextContent(&quot;What is the weather in New York?&quot;)]
  )
];

List&lt;Tool&gt; tools = [Tool.CreateFromClass&lt;GetWeatherTool&gt;()];

var response = await client.CreateMessageAsync(new MessageRequest(
  AnthropicModels.Claude3Haiku,
  messages,
  tools: tools
));

if (response.IsSuccess is false)
{
  Console.WriteLine(&quot;Failed to create message&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

messages.Add(new(MessageRole.Assistant, response.Content));


foreach (var content in response.Value.Content)
{
  switch (content)
  {
    case TextContent textContent:
      Console.WriteLine(textContent.Text);
      break;
    case ToolUseContent toolUseContent:
      Console.WriteLine(toolUseContent.Name);
      break;
  }
}

if (response.Value.ToolCall is not null)
{
  var toolCallResult = await response.Value.ToolCall.InvokeAsync&lt;string&gt;();
  string toolResultContent;

  if (toolCallResult.IsSuccess &amp;&amp; toolCallResult.Value is not null)
  {
    Console.WriteLine(toolCallResult.Value);
    toolResultContent = toolCallResult.Value;
  }
  else
  {
    Console.WriteLine(toolCallResult.Error.Message);
    toolResultContent = toolCallResult.Error.Message;
  }

  messages.Add(
    new(
      MessageRole.User, 
      [
        new ToolResultContent(
          response.Value.ToolCall.ToolUse.Id, 
          toolResultContent
        )
      ]
    )
  );
}

var finalResponse = await client.CreateMessageAsync(new MessageRequest(
  AnthropicModels.Claude3Haiku,
  messages,
  tools: tools
));

if (finalResponse.IsSuccess is false)
{
  Console.WriteLine(&quot;Failed to create message&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, finalResponse.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, finalResponse.Error.Error.Message);
  return;
}

foreach (var content in finalResponse.Value.Content)
{
  switch (content)
  {
    case TextContent textContent:
      Console.WriteLine(textContent.Text);
      break;
  }
}
</code></pre>
<p>If an exception is thrown while invoking the tool the <code>InvokeAsync</code> method will return a <code>ToolCallResult</code> with the exception contained in the <code>Error</code> property.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>InvokeAsync</code> method does accept a generic type parameter that can be used to specify the type of the <code>Value</code> property of the <code>ToolCallResult</code>. If it is not specified it will be an <code>object</code>.</p>
</div>
<h4 id="call-a-tool-in-streamed-message">Call a tool in streamed message</h4>
<p>Tool calling is also supported when streaming the message response. The following example demonstrates how you can handle a tool call in a streamed message response.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var tool = (string location, string units) =&gt; $&quot;The weather in {location} is 72 degrees {units}&quot;;

var messages = [
  new(
    MessageRole.User, 
    [new TextContent(&quot;What is the weather in New York?&quot;)]
  )
];

var tools = [Tool.CreateFromFunction(
  &quot;Get Weather&quot;, 
  &quot;Get the weather for a location in the specified units&quot;, 
  tool
)];

var events = client.CreateMessageAsync(new StreamMessageRequest(
  AnthropicModels.Claude3Haiku,
  messages,
  tools: tools
));

MessageResponse? response = null;

await foreach (var e in events)
{
  switch (e.Data)
  {
    case var data when data is MessageCompleteEventData msgData:
      response = msgData.Message;
      break;
  }
}

if (response is null)
{
  Console.WriteLine(&quot;Failed to get message response&quot;);
  return;
}

messages.Add(new(MessageRole.Assistant, response.Content));

if (response?.ToolCall is not null)
{
  var toolCallResult = await response.ToolCall.InvokeAsync&lt;string&gt;();
  string toolResultContent;

  if (toolCallResult.IsSuccess &amp;&amp; toolCallResult.Value is not null)
  {
    toolResultContent = toolCallResult.Value;
  }
  else
  {
    toolResultContent = toolCallResult.Error.Message;
  }

  messages.Add(
    new(
      MessageRole.User, 
      [
        new ToolResultContent(
          response.ToolCall.ToolUse.Id, 
          toolResultContent
        )
      ]
    )
  );
}

var finalResponse = await client.CreateMessageAsync(new MessageRequest(
  AnthropicModels.Claude3Haiku,
  messages,
  tools: tools
));

if (finalResponse.IsSuccess is false)
{
  Console.WriteLine(&quot;Failed to create message&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, finalResponse.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, finalResponse.Error.Error.Message);
  return;
}

foreach (var content in finalResponse.Value.Content)
{
  switch (content)
  {
    case TextContent textContent:
      Console.WriteLine(textContent.Text);
      break;
  }
}
</code></pre>
<p>If you do find that you need more control over how exactly provided tools are called and how the result of those tools are returned you can avoid using the <code>InvokeAsync</code> method and instead use the <code>Tool</code> and <code>ToolUse</code> properties of the <code>ToolCall</code> instance to implement your own solution.</p>
<h3 id="system-prompt">System Prompt</h3>
<p>Anthropic's models support the use of system prompts to provide additional context to the user. This can be used to provide additional information to the user or to ask for additional information from the user. This feature is covered in depth in <a href="https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/system-prompts">Anthropic's API Documentation</a>. This library aims to make using system prompts convenient by allowing you to provide the system prompts you want Anthropic's models to consider for use when creating a message.</p>
<h4 id="system-message">System Message</h4>
<p>You can create a system prompt by providing a <code>string</code> as the <code>system</code> parameter in the <code>MessageRequest</code> or <code>StreamMessageRequest</code> constructor.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var response = await client.CreateMessageAsync(new MessageRequest(
  AnthropicModels.Claude3Haiku,
  [
    new(
      MessageRole.User, 
      [new TextContent(&quot;Please write a haiku about the ocean.&quot;)]
    )
  ],
  system: &quot;You are a internationally renowned poet. You excel at writing haikus.
));

if (response.IsSuccess is false)
{
  Console.WriteLine(&quot;Failed to create message&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

foreach (var content in response.Value.Content)
{
  switch (content)
  {
    case TextContent textContent:
      Console.WriteLine(textContent.Text);
      break;
  }
}
</code></pre>
<h4 id="system-messages">System Messages</h4>
<p>You can create a more complex system prompt by providing a <code>List&lt;TextContent&gt;</code> as the <code>systemMessages</code> parameter in the <code>MessageRequest</code> or <code>StreamMessageRequest</code> constructor.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var response = await client.CreateMessageAsync(new MessageRequest(
  AnthropicModels.Claude3Haiku,
  [
    new(
      MessageRole.User, 
      [new TextContent(&quot;Please write a haiku about the ocean.&quot;)]
    )
  ],
  systemMessages: [
    new TextContent(&quot;You are a internationally renowned poet. You excel at writing haikus.&quot;),
    new TextContent(&quot;You have been asked to write a haiku about the ocean.&quot;)
  ]
));

if (response.IsSuccess is false)
{
  Console.WriteLine(&quot;Failed to create message&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

foreach (var content in response.Value.Content)
{
  switch (content)
  {
    case TextContent textContent:
      Console.WriteLine(textContent.Text);
      break;
  }
}
</code></pre>
<h3 id="prompt-caching">Prompt Caching</h3>
<p>Anthropic provides a feature called <a href="https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching">Prompt Caching</a> that allows you to cache all or part of the prompt you send to the model. This can be used to improve the performance of your application by reducing latency and token usage. This feature is covered in depth in <a href="https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching">Anthropic's API Documentation</a>.</p>
<p>Prompt caching can be used to cache all parts of the prompt including system messages, user messages, and tools. You should refer to the <a href="https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching">Anthropic API Documentation</a> for specifics on limitations and requirements for using prompt caching. This library aims to make using prompt caching convenient and give you complete control over what parts of the prompt are cached. Currently there is only one type of cache control available - <code>EphemeralCacheControl</code>.</p>
<h4 id="caching-system-messages">Caching System Messages</h4>
<p>System messages can be cached by providing a <code>List&lt;TextContent&gt;</code> as the <code>systemMessages</code> parameter in the <code>MessageRequest</code> or <code>StreamMessageRequest</code> constructor and having one or more of the <code>TextContent</code> instances have the <code>CacheControl</code> property set.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var response = await client.CreateMessageAsync(new MessageRequest(
  AnthropicModels.Claude3Haiku,
  [
    new(
      MessageRole.User, 
      [new TextContent(&quot;Please write a haiku about the ocean.&quot;)]
    )
  ],
  systemMessages: [
    new TextContent(&quot;You are a internationally renowned poet. You excel at writing haikus. Please use the following as examples.&quot;),
    new TextContent(exampleHaikus, new EphemeralCacheControl())
  ]
));

if (response.IsSuccess is false)
{
  Console.WriteLine(&quot;Failed to create message&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

foreach (var content in response.Value.Content)
{
  switch (content)
  {
    case TextContent textContent:
      Console.WriteLine(textContent.Text);
      break;
  }
}
</code></pre>
<h4 id="caching-user-messages">Caching User Messages</h4>
<p>User messages can be cached by providing a <code>List&lt;Content&gt;</code> as the <code>messages</code> parameter in the <code>MessageRequest</code> or <code>StreamMessageRequest</code> constructor and having one or more of the <code>Content</code> instances have the <code>CacheControl</code> property set.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var response = await client.CreateMessageAsync(new MessageRequest(
  AnthropicModels.Claude3Haiku,
  [
    new(
      MessageRole.User, 
      [
        new TextContent(&quot;Please write a haiku about the ocean. Here are some examples of haikus I like.&quot;),
        new TextContent(exampleHaikus, new EphemeralCacheControl())
      ]
    ),
  ]
));

if (response.IsSuccess is false)
{
  Console.WriteLine(&quot;Failed to create message&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

foreach (var content in response.Value.Content)
{
  switch (content)
  {
    case TextContent textContent:
      Console.WriteLine(textContent.Text);
      break;
  }
}
</code></pre>
<h4 id="caching-tools">Caching Tools</h4>
<p>Tools can be cached by providing a <code>List&lt;Tool&gt;</code> as the <code>tools</code> parameter in the <code>MessageRequest</code> or <code>StreamMessageRequest</code> constructor and having one or more of the <code>Tool</code> instances have the <code>CacheControl</code> property set. This property can be set after the tool is created manually or by using one of the static methods on the <code>Tool</code> class.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var tool = (string location, string units) =&gt; $&quot;The weather in {location} is 72 degrees {units}&quot;;

var getWeatherTool = Tool.CreateFromFunction(
  &quot;Get Weather&quot;, 
  &quot;Get the weather for a location in the specified units&quot;, 
  tool,
  new EphemeralCacheControl()
);

var response = await client.CreateMessageAsync(new MessageRequest(
  AnthropicModels.Claude3Haiku,
  [
    new(
      MessageRole.User, 
      [new TextContent(&quot;What is the weather in New York?&quot;)]
    )
  ],
  tools: [
    // Lots of other tools
    // ...
    getWeatherTool
  ]
));

if (response.IsSuccess is false)
{
  Console.WriteLine(&quot;Failed to create message&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

foreach (var content in response.Value.Content)
{
  switch (content)
  {
    case TextContent textContent:
      Console.WriteLine(textContent.Text);
      break;
    case ToolUseContent toolUseContent:
      Console.WriteLine(toolUseContent.Name);
      break;
  }
}
</code></pre>
<h3 id="pdf-support">PDF Support</h3>
<p>Anthropic provides a feature called <a href="https://docs.anthropic.com/en/docs/build-with-claude/pdf-support">PDF Support</a> that allows Claude to support PDF input and understand both text and visual content within documents. This feature is covered in depth in <a href="https://docs.anthropic.com/en/docs/build-with-claude/pdf-support">Anthropic's API Documentation</a>.</p>
<p>PDF support can be used to provide a PDF document as input to the model. This can be used to provide additional context to the model or to ask for additional information from the model. This library aims to make using PDF support convenient by allowing you to provide the PDF document you want Anthropic's models to consider for use when creating a message.</p>
<h4 id="pdf-document">PDF Document</h4>
<p>You can provide a PDF document by providing its base64 encoded content as a <code>DocumentContent</code> instance in the list of messages in the <code>MessageRequest</code> or <code>StreamMessageRequest</code> constructor.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var request = new MessageRequest(
  model: AnthropicModels.Claude35Sonnet,
  messages: [
    new(MessageRole.User, [new TextContent(&quot;What is the title of this paper?&quot;)]),
    new(MessageRole.User, [new DocumentContent(&quot;application/pdf&quot;, base64Data)])
  ]
);

var response = await client.CreateMessageAsync(request);

if (response.IsSuccess is false)
{
  Console.WriteLine(&quot;Failed to create message&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

foreach (var content in response.Value.Content)
{
  switch (content)
  {
    case TextContent textContent:
      Console.WriteLine(textContent.Text);
      break;
  }
}
</code></pre>
<h3 id="message-batches">Message Batches</h3>
<p>Anthropic provides a feature called <a href="https://docs.anthropic.com/en/docs/build-with-claude/message-batches">Message Batches</a> that allows you to send multiple messages in a single request. This feature is covered in depth in <a href="https://docs.anthropic.com/en/docs/build-with-claude/message-batches">Anthropic's API Documentation</a>.</p>
<h4 id="create-a-message-batch">Create a message batch</h4>
<p>You can create a message batch that will consist of one or more requests to create messages.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var request = new MessageBatchRequest([
  new(
    Guid.NewGuid().ToString(),
    new(
      model: AnthropicModels.Claude3Haiku,
      messages: [new(MessageRole.User, [new TextContent(&quot;Hello!&quot;)])]
    )
  ),
]);

var response = await client.CreateMessageBatchAsync(request);

if (response.IsFailure)
{
  Console.WriteLine(&quot;Failed to create message batch&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

Console.WriteLine(&quot;Message Batch Id: {0}&quot;, response.Value.Id);
</code></pre>
<h4 id="get-a-message-batch">Get a message batch</h4>
<p>You can retrieve a message batch by its id.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var response = await client.GetMessageBatchAsync(&quot;batch-id&quot;);

if (response.IsFailure)
{
  Console.WriteLine(&quot;Failed to get message batch&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

Console.WriteLine(&quot;Message Batch Id: {0}&quot;, response.Value.Id);
</code></pre>
<h4 id="get-a-message-batch-results">Get a message batch results</h4>
<p>You can retrieve the results of a message batch by its id. The results are returned as an <code>IAsyncEnumerable</code> collection so that they can be streamed and processed as they are received.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var response = await client.GetMessageBatchResultsAsync(&quot;batch-id&quot;);

if (response.IsFailure)
{
  Console.WriteLine(&quot;Failed to get message batch results&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

await foreach (var item in response.Value)
{
  Console.WriteLine(&quot;Item Custom Id: {0}&quot;, result.CustomId);
  
  switch (item.Result)
  {
    case SucceededMessageBatchResult successResult:
      foreach (var content in successResult.Message.Content)
      {
        if (content is TextContent textContent)
        {
          Console.WriteLine(&quot;Message Batch Result: {0}&quot;, textContent.Text);
        }
      }
      break;
    default:
      Console.WriteLine(&quot;Message Batch Result: {0}&quot;, item.Result.Type);
      break;
  }
}
</code></pre>
<h4 id="list-message-batches">List message batches</h4>
<p>You can retrieve a page of message batches.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var response = await client.ListMessageBatchesAsync();

if (response.IsFailure)
{
  Console.WriteLine(&quot;Failed to list message batches&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

foreach (var batch in response.Value.Data)
{
  Console.WriteLine(&quot;Message Batch Id: {0}&quot;, batch.Id);
}
</code></pre>
<h4 id="list-all-message-batches">List all message batches</h4>
<p>You can also retrieve all the pages of message batches without having to implement pagination yourself. This is done by returning an <code>IAsyncEnumerable</code> collection that can be streamed and processed as the pages are received.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var pageResponses = client.ListAllMessageBatchesAsync();

await foreach (var response in pageResponses)
{
  if (response.IsFailure)
  {
    Console.WriteLine(&quot;Failed to list message batches&quot;);
    Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
    Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
    return;
  }

  foreach (var batch in response.Value.Data)
  {
    Console.WriteLine(&quot;Message Batch Id: {0}&quot;, batch.Id);
  }
}
</code></pre>
<h4 id="cancel-a-message-batch">Cancel a message batch</h4>
<p>You can cancel a message batch by its id.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var response = await client.CancelMessageBatchAsync(&quot;batch-id&quot;);

if (response.IsFailure)
{
  Console.WriteLine(&quot;Failed to cancel message batch&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

Console.WriteLine(&quot;Message Batch Id: {0}&quot;, response.Value.Id);
Console.WriteLine(&quot;Message Batch Status: {0}&quot;, response.Value.ProcessingStatus);
</code></pre>
<h4 id="delete-a-message-batch">Delete a message batch</h4>
<p>You can delete a message batch that is no longer being processed by its id.</p>
<pre><code class="lang-csharp">using AnthropicClient;
using AnthropicClient.Models;

var response = await client.DeleteMessageBatchAsync(&quot;batch-id&quot;);

if (response.IsFailure)
{
  Console.WriteLine(&quot;Failed to delete message batch&quot;);
  Console.WriteLine(&quot;Error Type: {0}&quot;, response.Error.Error.Type);
  Console.WriteLine(&quot;Error Message: {0}&quot;, response.Error.Error.Message);
  return;
}

Console.WriteLine(&quot;Message Batch Id: {0}&quot;, response.Value.Id);
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/StevanFreeborn/anthropic-client/blob/main/docfx/index.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
